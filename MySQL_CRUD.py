# -*- coding: utf-8 -*-
"""Sistemas Operativos -  Practica en equipos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10jawH-YLkePm1dt7pmVzbR5wa52n74xi
"""

# Importa la biblioteca mysql.connector para conectarse a MySQL.
import mysql.connector

# Solicita al usuario ingresar los datos de conexión (nombre de usuario y contraseña).
user = input("Ingrese el nombre de usuario: ")
password = input("Ingrese la contraseña: ")

# Establece la conexión a MySQL sin seleccionar una base de datos específica.
db_conexion = mysql.connector.connect(
    host='localhost',  # Dirección del servidor de base de datos (en este caso, localhost).
    user=user,          # Nombre de usuario proporcionado por el usuario.
    password=password)  # Contraseña proporcionada por el usuario.

# Crea un cursor para ejecutar consultas en la base de datos.
db = db_conexion.cursor(buffered=True)

# Define una función para obtener las bases de datos disponibles en el servidor MySQL.
def obtener_bases_de_datos():
    # Consulta las bases de datos disponibles en el servidor.
    db.execute("SHOW DATABASES")
    bases_de_datos = [bd[0] for bd in db.fetchall()]  # Recupera los nombres de las bases de datos.
    return bases_de_datos

# Define una función para que el usuario seleccione una base de datos.
def seleccionar_base_de_datos():
    bases_de_datos = obtener_bases_de_datos()
    print("Bases de datos disponibles:")
    for i, bd in enumerate(bases_de_datos, start=1):
        print(f"{i}. {bd}")

    # Solicita al usuario seleccionar una base de datos mediante un número.
    while True:
        try:
            opcion = int(input("Seleccione una base de datos (por número): "))
            if 1 <= opcion <= len(bases_de_datos):
                return bases_de_datos[opcion - 1]  # Devuelve el nombre de la base de datos seleccionada.
            else:
                print("Opción no válida. Intente nuevamente.")
        except ValueError:
            print("Por favor, ingrese un número válido.")

# Solicita al usuario seleccionar una base de datos.
database = seleccionar_base_de_datos()

# Establece la conexión a la base de datos seleccionada.
db_conexion = mysql.connector.connect(
    host='localhost',
    user=user,
    password=password,
    database=database)

# Actualiza el cursor para la nueva conexión a la base de datos.
db = db_conexion.cursor(buffered=True)

# Define una función para obtener las tablas disponibles en la base de datos actual.
def obtener_tablas():
    # Consulta las tablas disponibles en la base de datos actual.
    db.execute("SHOW TABLES")
    tablas = [tabla[0] for tabla in db.fetchall()]  # Recupera los nombres de las tablas.
    return tablas

# Define una función para que el usuario seleccione una tabla.
def seleccionar_tabla():
    tablas = obtener_tablas()
    print("Tablas disponibles:")
    for i, tabla in enumerate(tablas, start=1):
        print(f"{i}. {tabla}")

    # Solicita al usuario seleccionar una tabla mediante un número.
    while True:
        try:
            opcion = int(input("Seleccione una tabla (por número): "))
            if 1 <= opcion <= len(tablas):
                return tablas[opcion - 1]  # Devuelve el nombre de la tabla seleccionada.
            else:
                print("Opción no válida. Intente nuevamente.")
        except ValueError:
            print("Por favor, ingrese un número válido.")

# Define una función para obtener las columnas y tipos de datos de una tabla.
def obtener_columnas_y_tipos(tabla):
    db.execute(f"DESCRIBE {tabla}")
    columnas_y_tipos = [(columna[0], columna[1]) for columna in db.fetchall()]  # Recupera nombres de columnas y tipos de datos.
    return columnas_y_tipos

# Define una función para obtener la clave primaria de una tabla.
def obtener_clave_primaria(tabla):
    db.execute(f"SHOW KEYS FROM {tabla} WHERE Key_name = 'PRIMARY'")
    clave_primaria = db.fetchone()
    if clave_primaria:
        return clave_primaria[4]  # Devuelve el nombre de la columna de la clave primaria.
    else:
        # Si no hay clave primaria definida, toma el primer campo de izquierda a derecha como clave primaria.
        columnas_y_tipos = obtener_columnas_y_tipos(tabla)
        return columnas_y_tipos[0][0] if columnas_y_tipos else None

# Define una función para mostrar las columnas y tipos de datos de una tabla.
def mostrar_columnas_y_tipos(tabla):
    columnas = obtener_columnas_y_tipos(tabla)
    print("Recuerda que para poder insertar los datos, deberás ingresarlos en el mismo orden que se muestran a continuación, y con el tipo de dato correcto")
    print(columnas)

# Define una función para cerrar la conexión a la base de datos y salir del programa.
def cerrar_conexion():
    db.close()
    exit()

# Define una función para leer y mostrar todos los registros de una tabla.
def leer_registros(tabla):
    query = f"SELECT * FROM {tabla}"
    db.execute(query)
    resultados = db.fetchall()

    for resultado in resultados:
        print(resultado)

# Define una función para insertar un nuevo registro en una tabla.
def insertar_registro(tabla):
    mostrar_columnas_y_tipos(tabla)
    valores = {}

    for columna, tipo in obtener_columnas_y_tipos(tabla):
        valor = input(f"Ingrese el valor para {columna} ({tipo}): ").strip()
        valores[columna] = valor

    clave_primaria = obtener_clave_primaria(tabla)

    if not clave_primaria:
        print("No se puede realizar la inserción. No se encontró una clave primaria definida.")
        return

    # Construye la consulta INSERT dinámicamente con las columnas y valores ingresados por el usuario.
    columnas = ', '.join(valores.keys())
    placeholders = ', '.join(['%s'] * len(valores))
    query = f"INSERT INTO {tabla} ({columnas}) VALUES ({placeholders})"

    db.execute(query, tuple(valores.values()))
    db_conexion.commit()

    print("Registro agregado exitosamente")

# Define una función para eliminar un registro de una tabla.
def baja_registro(tabla):
    mostrar_columnas_y_tipos(tabla)
    valor_busqueda = input("Ingrese el valor para buscar el registro a eliminar: ").strip()

    clave_primaria = obtener_clave_primaria(tabla)

    if not clave_primaria:
        print("No se puede realizar la baja. No se encontró una clave primaria definida.")
        return

    consulta_registro = f"SELECT * FROM {tabla} WHERE {clave_primaria} = %s"
    db.execute(consulta_registro, (valor_busqueda,))
    registro = db.fetchone()

    if registro:
        print("Registro a eliminar:")
        print(registro)

        confirmacion = input("¿Está seguro de que desea eliminar este registro? (s/n): ")
        if confirmacion.lower() == "s":
            consulta_baja = f"DELETE FROM {tabla} WHERE {clave_primaria} = %s"
            db.execute(consulta_baja, (valor_busqueda,))
            db_conexion.commit()

            print("Registro eliminado exitosamente")
        else:
            print("Baja cancelada")
    else:
        print("Registro no encontrado")

# Define una función para modificar un registro de una tabla.
def modifica_registro(tabla):
    mostrar_columnas_y_tipos(tabla)
    valor_busqueda = input("Ingrese el valor para buscar el registro a modificar: ")

    clave_primaria = obtener_clave_primaria(tabla)

    if not clave_primaria:
        print("No se puede realizar la modificación. No se encontró una clave primaria definida.")
        return

    consulta_actual = f"SELECT * FROM {tabla} WHERE {clave_primaria} = %s"
    db.execute(consulta_actual, (valor_busqueda,))
    registro_actual = db.fetchone()

    if registro_actual:
        print("Registro actual:")
        print(registro_actual)

        nuevos_valores = {}

        for columna, tipo in obtener_columnas_y_tipos(tabla):
            valor = input(f"Ingrese el nuevo valor para {columna} ({tipo}): ").strip()
            nuevos_valores[columna] = valor

        set_clause = ', '.join([f"{columna} = %s" for columna in nuevos_valores.keys()])
        query = f"UPDATE {tabla} SET {set_clause} WHERE {clave_primaria} = %s"

        db.execute(query, tuple(list(nuevos_valores.values()) + [valor_busqueda]))
        db_conexion.commit()

        print("Registro modificado exitosamente")
    else:
        print("Registro no encontrado")

# Define la función principal del programa.
def main():
    global tabla_seleccionada
    if db_conexion:
        print(f"Conectado a la base de datos '{database}'")

        # Muestra las tablas disponibles después de seleccionar la base de datos.
        tabla_seleccionada = None
        while not tabla_seleccionada:
            tabla_seleccionada = seleccionar_tabla()

        while True:
            print("\n--- Menú ---")
            print("1. Alta")
            print("2. Consulta")
            print("3. Modificación")
            print("4. Baja")
            print("5. Terminar")
            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                insertar_registro(tabla_seleccionada)
            elif opcion == "2":
                leer_registros(tabla_seleccionada)
            elif opcion == "3":
                modifica_registro(tabla_seleccionada)
            elif opcion == "4":
                baja_registro(tabla_seleccionada)
            elif opcion == "5":
                cerrar_conexion()
            else:
                print("Opción no válida")

        cerrar_conexion()

        print("Aplicación finalizada")

# Verifica si el programa se ejecuta como script principal.
if __name__ == "__main__":
    main()

